# ✅ 待办任务清单 - 杀伤链评估系统

**使用说明**: 按优先级和依赖关系完成任务，完成后在 [ ] 中打 ✓

---

## 🔴 P0 - 紧急且重要（核心功能缺失）

### Task 1: 网络连接可视化 ⭐⭐⭐
**状态**: [ ] 未开始  
**预计时间**: 1-2天  
**描述**: 当前只显示节点，不显示节点间的连接关系（edges），用户导入的78条边数据无法可视化

**实现位置**: `src/views/Simulation/index.vue` 的 `drawBattlefield()` 函数

**实现代码**:
```javascript
// 在 drawBattlefield() 函数中，绘制节点之前添加：

// 绘制连接线
const drawEdges = () => {
  networkStore.edges.forEach(edge => {
    const source = displayNodes.value.find(n => n.id === edge.source)
    const target = displayNodes.value.find(n => n.id === edge.target)
    
    if (!source || !target) return
    
    // 连接类型样式映射
    const edgeStyles = {
      'detection': { 
        color: '#409EFF', 
        width: 1.5,
        dash: [5, 5],
        label: '探测'
      },
      'communication': { 
        color: '#67C23A', 
        width: 2,
        dash: [],
        label: '通信'
      },
      'strike': { 
        color: '#F56C6C', 
        width: 2,
        dash: [10, 5],
        label: '支援'
      }
    }
    
    const style = edgeStyles[edge.type] || edgeStyles.communication
    
    // 绘制线条
    ctx.strokeStyle = style.color
    ctx.lineWidth = style.width / scale.value
    ctx.setLineDash(style.dash.map(d => d / scale.value))
    ctx.globalAlpha = 0.5
    
    ctx.beginPath()
    ctx.moveTo(source.x, source.y)
    ctx.lineTo(target.x, target.y)
    ctx.stroke()
    
    // 绘制箭头（可选）
    const angle = Math.atan2(target.y - source.y, target.x - source.x)
    const arrowSize = 8 / scale.value
    const arrowX = target.x - Math.cos(angle) * 35 // 离节点35px
    const arrowY = target.y - Math.sin(angle) * 35
    
    ctx.beginPath()
    ctx.moveTo(arrowX, arrowY)
    ctx.lineTo(
      arrowX - arrowSize * Math.cos(angle - Math.PI / 6),
      arrowY - arrowSize * Math.sin(angle - Math.PI / 6)
    )
    ctx.moveTo(arrowX, arrowY)
    ctx.lineTo(
      arrowX - arrowSize * Math.cos(angle + Math.PI / 6),
      arrowY - arrowSize * Math.sin(angle + Math.PI / 6)
    )
    ctx.stroke()
    
    ctx.globalAlpha = 1
    ctx.setLineDash([])
  })
}

// 调用绘制
drawEdges()  // 在绘制节点之前调用
```

**验收标准**:
- [ ] 导入网络后能看到节点间的连线
- [ ] 不同类型的连接有不同颜色和样式
- [ ] 连线随缩放正确显示
- [ ] 箭头方向正确

**依赖**: 无

---

### Task 2: 杀伤链分析核心功能 ⭐⭐⭐
**状态**: [ ] 未开始  
**预计时间**: 3-5天  
**描述**: 实现完整的杀伤链（Kill Chain）分析：探测→决策→打击→评估

**实现步骤**:

#### 2.1 创建杀伤链分析模块
**文件**: `src/utils/killChainAnalysis.js`

```javascript
// 杀伤链分析工具
export class KillChainAnalyzer {
  constructor(nodes, edges) {
    this.nodes = nodes
    this.edges = edges
  }
  
  // 1. 探测阶段 - 检查目标是否在探测范围内
  checkDetection(attacker, target) {
    // 查找探测链路
    const detectionPath = this.findDetectionPath(attacker, target)
    
    // 计算探测概率
    const detectionProb = this.calculateDetectionProbability(detectionPath)
    
    // 计算探测时间
    const detectionTime = this.calculateDetectionTime(detectionPath)
    
    return {
      canDetect: detectionProb > 0.5,
      probability: detectionProb,
      time: detectionTime,
      path: detectionPath
    }
  }
  
  // 2. 决策阶段 - 评估打击可行性
  makeDecision(attacker, target, detectionResult) {
    // 计算打击距离
    const distance = this.calculateDistance(attacker, target)
    
    // 检查打击范围
    const inRange = distance <= attacker.strikeRange || 500
    
    // 计算威胁等级
    const threatLevel = this.assessThreat(target)
    
    // 决策时间
    const decisionTime = 2 + Math.random() * 3 // 2-5秒
    
    return {
      approved: detectionResult.canDetect && inRange,
      distance,
      inRange,
      threatLevel,
      time: decisionTime
    }
  }
  
  // 3. 打击阶段 - 执行打击
  executeStrike(attacker, target, decisionResult) {
    if (!decisionResult.approved) {
      return {
        success: false,
        reason: '打击条件不满足'
      }
    }
    
    // 计算命中概率
    const hitProb = this.calculateHitProbability(
      attacker, 
      target, 
      decisionResult.distance
    )
    
    // 判定是否命中
    const hit = Math.random() < hitProb
    
    // 计算伤害
    const damage = hit ? this.calculateDamage(attacker, target) : 0
    
    // 打击时间
    const strikeTime = decisionResult.distance / 100 // 简化计算
    
    return {
      success: true,
      hit,
      damage,
      hitProbability: hitProb,
      time: strikeTime
    }
  }
  
  // 4. 评估阶段 - 评估打击效果
  assessEffect(strikeResult, target) {
    if (!strikeResult.success || !strikeResult.hit) {
      return {
        effectiveness: 0,
        targetStatus: 'active',
        recommendation: '目标未受损，建议重新打击'
      }
    }
    
    const remainingHP = target.hp - strikeResult.damage
    const effectiveness = strikeResult.damage / target.hp
    
    let targetStatus, recommendation
    
    if (remainingHP <= 0) {
      targetStatus = 'destroyed'
      recommendation = '目标已摧毁，任务完成'
    } else if (remainingHP < 30) {
      targetStatus = 'critical'
      recommendation = '目标重伤，建议补充打击'
    } else if (remainingHP < 70) {
      targetStatus = 'damaged'
      recommendation = '目标受损，建议继续打击'
    } else {
      targetStatus = 'minor'
      recommendation = '目标轻伤，建议集中火力'
    }
    
    return {
      effectiveness,
      targetStatus,
      remainingHP,
      recommendation
    }
  }
  
  // 完整杀伤链分析
  analyzeKillChain(attacker, target) {
    const startTime = Date.now()
    
    // 1. 探测
    const detection = this.checkDetection(attacker, target)
    
    // 2. 决策
    const decision = this.makeDecision(attacker, target, detection)
    
    // 3. 打击
    const strike = this.executeStrike(attacker, target, decision)
    
    // 4. 评估
    const assessment = this.assessEffect(strike, target)
    
    // 总时间
    const totalTime = detection.time + decision.time + 
                     (strike.time || 0)
    
    // 杀伤链完整性
    const chainComplete = detection.canDetect && 
                         decision.approved && 
                         strike.success
    
    return {
      detection,
      decision,
      strike,
      assessment,
      totalTime,
      chainComplete,
      effectiveness: assessment.effectiveness,
      timestamp: Date.now()
    }
  }
  
  // 辅助方法
  findDetectionPath(attacker, target) {
    // 实现探测链路查找（BFS/DFS）
    // 这里简化为直接探测
    return [attacker, target]
  }
  
  calculateDetectionProbability(path) {
    // 基于路径长度和节点类型计算
    return 0.8 - (path.length - 2) * 0.1
  }
  
  calculateDetectionTime(path) {
    return path.length * 2 // 简化：每跳2秒
  }
  
  calculateDistance(node1, node2) {
    return Math.sqrt(
      Math.pow(node1.x - node2.x, 2) + 
      Math.pow(node1.y - node2.y, 2)
    )
  }
  
  assessThreat(target) {
    const threatMap = {
      'command': 5,
      'striker': 4,
      'sensor': 3
    }
    return threatMap[target.type] || 3
  }
  
  calculateHitProbability(attacker, target, distance) {
    // 基础命中率
    let baseProb = 0.8
    
    // 距离惩罚
    const distancePenalty = Math.min(distance / 1000, 0.3)
    
    // 目标类型影响
    const typeBonus = target.type === 'command' ? 0.1 : 0
    
    return Math.max(0.1, baseProb - distancePenalty + typeBonus)
  }
  
  calculateDamage(attacker, target) {
    // 基础伤害
    const baseDamage = 25 + Math.random() * 30
    
    // 类型克制
    const typeBonus = attacker.type === 'striker' ? 1.2 : 1.0
    
    return Math.floor(baseDamage * typeBonus)
  }
}
```

#### 2.2 集成到推演组件
在 `Simulation/index.vue` 中：

```javascript
import { KillChainAnalyzer } from '@/utils/killChainAnalysis'

// 修改 executeAttack 函数
const executeAttack = () => {
  if (!selectedNodeId.value || !targetNodeId.value) {
    ElMessage.warning('请选择攻击节点和目标')
    return
  }
  
  const attacker = displayNodes.value.find(n => n.id === selectedNodeId.value)
  const target = displayNodes.value.find(n => n.id === targetNodeId.value)
  
  if (!attacker || !target || attacker.hp <= 0 || target.hp <= 0) return
  
  // 执行杀伤链分析
  const analyzer = new KillChainAnalyzer(displayNodes.value, networkStore.edges)
  const killChain = analyzer.analyzeKillChain(attacker, target)
  
  // 记录详细日志
  addLog(`[探测] ${killChain.detection.canDetect ? '成功' : '失败'} - 概率:${(killChain.detection.probability * 100).toFixed(0)}%`, 
         killChain.detection.canDetect ? 'success' : 'warning')
  
  addLog(`[决策] ${killChain.decision.approved ? '批准' : '拒绝'} - 距离:${killChain.decision.distance.toFixed(0)}px`, 
         killChain.decision.approved ? 'success' : 'warning')
  
  if (killChain.strike.success) {
    addLog(`[打击] ${killChain.strike.hit ? '命中' : '未命中'} - 伤害:${killChain.strike.damage}`, 
           killChain.strike.hit ? 'danger' : 'info')
  }
  
  addLog(`[评估] 效能:${(killChain.effectiveness * 100).toFixed(0)}% - ${killChain.assessment.recommendation}`, 
         'info')
  
  // 如果打击成功，更新HP
  if (killChain.chainComplete && killChain.strike.hit) {
    const newHp = Math.max(0, target.hp - killChain.strike.damage)
    networkStore.updateNode(target.id, { hp: newHp })
    
    // 绘制攻击动画
    drawAttackAnimation(attacker, target)
    
    setTimeout(() => {
      drawBattlefield()
      
      if (newHp === 0) {
        ElMessage.success(`${target.name} 已被摧毁！`)
      }
    }, 300)
  } else {
    ElMessage.warning('杀伤链未完成，打击失败')
  }
  
  attackCount.value++
  
  // 更新命中率
  if (killChain.strike.hit) {
    hitRate.value = ((attackCount.value - 1) * hitRate.value + 100) / attackCount.value
  } else {
    hitRate.value = ((attackCount.value - 1) * hitRate.value) / attackCount.value
  }
}
```

**验收标准**:
- [ ] 打击前进行探测判定
- [ ] 显示决策过程（距离、范围）
- [ ] 记录完整杀伤链日志
- [ ] 评估打击效果
- [ ] 给出后续建议

**依赖**: Task 1（可同时进行）

---

## 🟡 P1 - 重要但不紧急（增强功能）

### Task 3: 推演规则完善
**状态**: [ ] 未开始  
**预计时间**: 2-3天  

**子任务**:
- [ ] 3.1 添加探测范围限制（圆形范围）
- [ ] 3.2 添加打击距离限制
- [ ] 3.3 实现视线遮挡检测
- [ ] 3.4 添加节点属性配置面板

**依赖**: Task 2

---

### Task 4: 效能评估报告
**状态**: [ ] 未开始  
**预计时间**: 3-4天  

**子任务**:
- [ ] 4.1 统计数据收集（战损比、杀伤链完成率）
- [ ] 4.2 图表生成（使用ECharts）
- [ ] 4.3 报告导出（PDF/Word）
- [ ] 4.4 推演过程回放

**依赖**: Task 2

---

### Task 5: AI自动推演
**状态**: [ ] 未开始  
**预计时间**: 5-7天  

**子任务**:
- [ ] 5.1 敌方AI决策算法
- [ ] 5.2 目标优先级系统
- [ ] 5.3 自动反击机制
- [ ] 5.4 智能移动策略

**依赖**: Task 2, Task 3

---

## 🟢 P2 - 重要性较低（优化改进）

### Task 6: 后端API开发
**状态**: [ ] 未开始  
**预计时间**: 7-10天  

**技术选择**: Node.js + Express + PostgreSQL

**子任务**:
- [ ] 6.1 用户认证API
- [ ] 6.2 网络配置CRUD
- [ ] 6.3 推演记录保存
- [ ] 6.4 文件上传下载

---

### Task 7: 数据库设计与集成
**状态**: [ ] 未开始  
**预计时间**: 5-7天  

**子任务**:
- [ ] 7.1 数据表设计
- [ ] 7.2 数据迁移脚本
- [ ] 7.3 前端API对接
- [ ] 7.4 数据持久化

**依赖**: Task 6

---

### Task 8: 系统优化
**状态**: [ ] 未开始  
**预计时间**: 3-5天  

**子任务**:
- [ ] 8.1 添加TypeScript类型定义
- [ ] 8.2 编写单元测试
- [ ] 8.3 性能优化（大规模节点）
- [ ] 8.4 错误处理完善

---

## 📊 任务统计

**总任务数**: 8个主任务  
**P0任务**: 2个（关键）  
**P1任务**: 4个（重要）  
**P2任务**: 2个（优化）  

**预计总时间**: 
- P0: 4-7天
- P1: 15-22天
- P2: 15-22天
- **总计**: 34-51天

---

## 🎯 里程碑

### Milestone 1: 核心功能完整（P0完成）
**时间**: 1周  
**交付**: 可视化完整的推演系统，支持杀伤链分析

### Milestone 2: 功能增强（P0+P1完成）
**时间**: 3-4周  
**交付**: 完整的效能评估和AI推演

### Milestone 3: 系统完善（全部完成）
**时间**: 7-8周  
**交付**: 生产级系统，支持多用户和数据持久化

---

## 💡 工作建议

### 第一天
- [ ] 阅读项目交接文档
- [ ] 熟悉现有代码
- [ ] 测试导入功能
- [ ] 开始 Task 1

### 第一周
- [ ] 完成 Task 1（网络连接可视化）
- [ ] 开始 Task 2（杀伤链分析）
- [ ] 每日测试和迭代

### 第二周
- [ ] 完成 Task 2
- [ ] 开始 Task 3 或 Task 4
- [ ] 准备演示版本

---

## ✅ 每日检查清单

每天结束前确认：
- [ ] 代码已提交到Git
- [ ] 更新了任务状态
- [ ] 记录了遇到的问题
- [ ] 更新了文档
- [ ] 测试了新功能

---

**记住**: P0任务是核心价值，必须优先完成！
